<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Interactive Distance vs. Time Grapher</title>
<style>
body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:16px;background:#eef1f5;color:#333;display:flex;flex-direction:column;align-items:center}
.container{background:#fff;padding:20px;border-radius:12px;box-shadow:0 4px 15px rgba(0,0,0,.1);width:98%;max-width:1600px;margin-bottom:25px}
.grid{display:grid;grid-template-columns:1fr;gap:24px;align-items:start}
@media (min-width:960px){.grid{grid-template-columns:1fr 1fr}}
.col{display:flex;flex-direction:column;gap:24px;min-width:0}
.col>*{width:100%}
.card{padding:20px;border:1px solid #dbe0e6;border-radius:10px;background:#f9fafb}
.tight{padding:14px}
.no-mb>*{margin-bottom:0}
.title{font-weight:700}
.subtle{opacity:.85}
h1,h2{color:#2c3e50;text-align:center;margin-top:0}h1{margin-bottom:20px;font-size:28px}h2{margin-bottom:15px;font-size:20px}
.controls,.simulation-area,.graph-area,.explanation,.helper{padding:20px;border:1px solid #dbe0e6;border-radius:8px;background:#f9fafb}
label{display:inline-block;margin-right:8px;margin-bottom:8px;font-weight:500}
input[type="number"],input[type="text"]{padding:10px;margin-right:10px;margin-bottom:10px;border:1px solid #ccc;border-radius:6px;box-sizing:border-box}
input[type="number"]{width:90px}
button{padding:10px 18px;background:#3498db;color:#fff;border:none;border-radius:6px;cursor:pointer;margin-right:8px;transition:background-color .2s ease-in-out;font-weight:500}
button:hover{background:#2980b9}
#resetBtn{background:#e74c3c}#resetBtn:hover{background:#c0392b}
#explainBtn{background:#2ecc71}#explainBtn:hover{background:#27ae60}
#segmentsList{list-style:decimal;padding-left:25px}
#segmentsList li{margin-bottom:6px;background:#e9edf0;padding:8px;border-radius:4px;font-size:.95em}
.simulation-area{position:relative;background:#f9fafb;border:1px solid #c8cdd3;overflow:hidden}
#simCanvas{border:1px solid #b0b8c0;background:#fff;display:block;margin:8px auto 0;width:100%;height:90px;box-sizing:border-box}
#simInfo{position:absolute;top:5px;right:10px;font-size:.9em;background:rgba(255,255,255,.85);padding:5px 8px;border-radius:4px}
canvas.graph{border:1px solid #b0b8c0;background:#fff;display:block;margin:6px auto 0;cursor:crosshair;width:100%;min-height:280px;box-sizing:border-box}
#hoverInfo{position:absolute;background:rgba(0,0,0,.75);color:#fff;padding:5px 8px;border-radius:4px;font-size:.85em;pointer-events:none;display:none}
.helper textarea{width:calc(100% - 22px);min-height:140px;margin-top:10px;padding:10px;border:1px solid #ccc;border-radius:6px;font-family:inherit;font-size:.95em;resize:vertical;white-space:pre-wrap}
details{background:#eef2f6;border:1px solid #dbe0e6;border-radius:6px;padding:10px;margin:8px 0}
details summary{cursor:pointer;font-weight:600}
.badge{display:inline-block;vertical-align:middle;border:1px solid #ccd2da;background:#f1f5f9;border-radius:999px;padding:2px 8px;font-size:.8em;margin-left:6px}
*,*::before,*::after{box-sizing:border-box}
</style>
</head>
<body>
<div id="hoverInfo"></div>
<div class="container">
<h1>Interactive Distance vs. Time Graph Simulator</h1>
<div class="grid">
<div class="col left">
<div class="explanation card">
<h2>How to Use This Page</h2>
<ul>
<li>Add one or more segments with a velocity (m/s) and a duration (s).</li>
<li>Click <em>Run Simulation & Graph</em> to animate and plot distance vs. time.</li>
<li>Hover the graph to read exact (time, distance) values.</li>
<li>Click <em>Explain My Run</em> to generate a tailored, student-friendly explanation.</li>
</ul>
</div>
<div class="controls card">
<h2>Define Motion Segments</h2>
<div>
<label for="velocity">Velocity (m/s):</label>
<input type="number" id="velocity" value="2" step="0.5">
<label for="duration">Duration (s):</label>
<input type="number" id="duration" value="5" min="0.1" step="0.1">
<button id="addSegmentBtn">Add Segment</button>
</div>
<h3>Current Segments:</h3>
<ul id="segmentsList"></ul>
<div>
<button id="runBtn">Run Simulation & Graph</button>
<button id="resetBtn">Reset All</button>
<button id="explainBtn" title="Generate a plain-English summary for students">Explain My Run</button>
<span class="badge" title="No downloads or servers required">Lightweight</span>
</div>
</div>
<div class="faq card">
<h2>FAQ: Interpreting Distance–Time Graphs</h2>
<ul>
<li><strong>Slope = velocity.</strong> Steeper = faster. Flat = 0 m/s (rest). Negative slope = moving toward the start.</li>
<li><strong>Straight line</strong> means constant velocity. <strong>Curved line</strong> means changing velocity (acceleration).</li>
<li><strong>Average velocity</strong> over an interval: Δdistance ÷ Δtime.</li>
<li><strong>Total distance</strong> adds signed changes; if you need <em>path length</em>, use absolute values.</li>
</ul>
</div>
</div>
<div class="col right">
<div class="simulation-area card tight">
<h2>Animation</h2>
<canvas id="simCanvas" height="90"></canvas>
<div id="simInfo">
<div>Time: <span id="timeDisplay">0.0</span>s</div>
<div>Distance: <span id="distanceDisplay">0.0</span>m</div>
</div>
</div>
<div class="graph-area card">
<h2>Distance vs. Time Graph</h2>
<canvas id="dvtGraph" class="graph"></canvas>
</div>
<div class="helper card">
<h2>Smart Helper Explanation</h2>
<p>This helper generates explanations using rules and your inputs.</p>
<textarea id="helperOutput" readonly placeholder="Click ‘Explain My Run’ for a tailored summary…"></textarea>
</div>
</div>
</div>
</div>
<script>
const velocityInput=document.getElementById('velocity');
const durationInput=document.getElementById('duration');
const addSegmentBtn=document.getElementById('addSegmentBtn');
const segmentsListEl=document.getElementById('segmentsList');
const runBtn=document.getElementById('runBtn');
const resetBtn=document.getElementById('resetBtn');
const explainBtn=document.getElementById('explainBtn');
const simCanvas=document.getElementById('simCanvas');
const snl=simCanvas.getContext('2d');
const graphCanvas=document.getElementById('dvtGraph');
const ctx=graphCanvas.getContext('2d');
const timeDisplay=document.getElementById('timeDisplay');
const distanceDisplay=document.getElementById('distanceDisplay');
const hoverInfo=document.getElementById('hoverInfo');
const helperOutput=document.getElementById('helperOutput');
let timeCursor=0;
let segments=[];
let animationFrameId=null;
const padding=60;const tickSize=6;
let allDataPoints=[];let currentMaxTime=0;let currentMaxDistance=0;
function sizeSimCanvas(){const dpr=window.devicePixelRatio||1;const cssW=simCanvas.clientWidth;const cssH=simCanvas.clientHeight;simCanvas.width=Math.max(1,Math.floor(cssW*dpr));simCanvas.height=Math.max(1,Math.floor(cssH*dpr));snl.setTransform(dpr,0,0,dpr,0,0)}
function sizeGraphCanvas(){const dpr=window.devicePixelRatio||1;const cssW=graphCanvas.clientWidth;const cssH=parseFloat(getComputedStyle(graphCanvas).height)||420;graphCanvas.width=Math.max(1,Math.floor(cssW*dpr));graphCanvas.height=Math.max(1,Math.floor(cssH*dpr));ctx.setTransform(dpr,0,0,dpr,0,0);if(currentMaxTime>0){drawAxes(currentMaxTime,currentMaxDistance);drawGraphLine();drawTimeCursor()}}
function layoutGraphSize(){const colW=graphCanvas.parentElement.clientWidth||900;const targetH=Math.max(300,Math.min(520,Math.round(colW*0.5)));graphCanvas.style.height=`${targetH}px`;sizeGraphCanvas()}
window.addEventListener('resize',()=>{layoutGraphSize();sizeSimCanvas();if(lastSimState)drawSimNumberLine(lastSimState.min,lastSimState.max,lastSimState.current)});
if('ResizeObserver'in window){const ro=new ResizeObserver(()=>{layoutGraphSize()});ro.observe(graphCanvas.parentElement)}
sizeSimCanvas();
layoutGraphSize();
addSegmentBtn.addEventListener('click',()=>{const velocity=parseFloat(velocityInput.value);const duration=parseFloat(durationInput.value);if(isNaN(duration)||duration<=0){alert('Please enter a valid positive duration.');return}if(isNaN(velocity)){alert('Please enter a valid velocity.');return}segments.push({velocity,duration});renderSegmentsList()});
runBtn.addEventListener('click',()=>{if(!segments.length){alert('Please add at least one motion segment.');return}if(animationFrameId)cancelAnimationFrame(animationFrameId);generateDataAndAnimate()});
resetBtn.addEventListener('click',()=>{segments=[];allDataPoints=[];currentMaxTime=0;currentMaxDistance=0;renderSegmentsList();clearGraph();helperOutput.value='';if(animationFrameId)cancelAnimationFrame(animationFrameId);timeDisplay.textContent='0.0';distanceDisplay.textContent='0.0';drawSimNumberLine(0,10,0)});
function renderSegmentsList(){segmentsListEl.innerHTML='';segments.forEach((seg,i)=>{const li=document.createElement('li');li.textContent=`Segment ${i+1}: Velocity = ${seg.velocity.toFixed(1)} m/s, Duration = ${seg.duration.toFixed(1)} s`;segmentsListEl.appendChild(li)})}
function clearGraph(){ctx.clearRect(0,0,graphCanvas.width,graphCanvas.height);drawAxes(10,10);hoverInfo.style.display='none'}
function computeYBounds(fallbackMax){if(allDataPoints.length){let minD=allDataPoints.reduce((m,p)=>Math.min(m,p.distance),allDataPoints[0].distance);let maxD=allDataPoints.reduce((m,p)=>Math.max(m,p.distance),allDataPoints[0].distance);if(minD===maxD){return{yMin:minD-1,yMax:maxD+1}}return{yMin:minD,yMax:maxD}}else{const fm=Number.isFinite(fallbackMax)&&fallbackMax>0?fallbackMax:10;return{yMin:0,yMax:fm}}}
function drawAxes(maxTime,maxDistance){const cw=graphCanvas.clientWidth;const ch=parseFloat(getComputedStyle(graphCanvas).height)||graphCanvas.clientHeight;ctx.clearRect(0,0,cw,ch);ctx.strokeStyle='#333';ctx.lineWidth=1.5;ctx.setLineDash([]);ctx.font="12px 'Segoe UI', Arial";ctx.fillStyle='#333';ctx.textAlign='center';ctx.beginPath();ctx.moveTo(padding,padding);ctx.lineTo(padding,ch-padding);ctx.stroke();ctx.beginPath();ctx.moveTo(padding,ch-padding);ctx.lineTo(cw-padding,ch-padding);ctx.stroke();ctx.save();ctx.translate(padding/2-15,ch/2);ctx.rotate(-Math.PI/2);ctx.fillText('Distance (m)',0,0);ctx.restore();ctx.fillText('Time (s)',cw/2,ch-padding/2+5);const numXTicks=Math.max(5,Math.min(10,Math.ceil(maxTime)));if(maxTime>0){for(let i=0;i<=numXTicks;i++){const t=maxTime/numXTicks*i;const x=padding+(t/maxTime)*(cw-2*padding);ctx.beginPath();ctx.moveTo(x,ch-padding);ctx.lineTo(x,ch-padding+tickSize);ctx.stroke();if(i>0||maxTime===0)ctx.fillText(t.toFixed(1),x,ch-padding+20)}}else{ctx.beginPath();ctx.moveTo(padding,ch-padding);ctx.lineTo(padding,ch-padding+tickSize);ctx.stroke()}const{yMin,yMax}=computeYBounds(maxDistance);let yRange=yMax-yMin;if(yRange<=0)yRange=1;const yStep=niceStep(yRange/6);const firstYTick=Math.ceil(yMin/yStep)*yStep;const fmt=v=>Math.abs(v-Math.round(v))<1e-6?String(Math.round(v)):(Math.abs(yStep)<1?v.toFixed(1):v.toFixed(0));ctx.textAlign='right';for(let v=firstYTick;v<=yMax+1e-9;v+=yStep){const y=ch-padding-((v-yMin)/yRange)*(ch-2*padding);ctx.beginPath();ctx.moveTo(padding,y);ctx.lineTo(padding-tickSize,y);ctx.stroke();ctx.fillText(fmt(v),padding-10,y+4)}if(yMin<0&&yMax>0){const yZero=ch-padding-((0-yMin)/yRange)*(ch-2*padding);ctx.beginPath();ctx.moveTo(padding,yZero);ctx.lineTo(padding-tickSize,yZero);ctx.stroke();ctx.fillText('0',padding-10,yZero+4)}}
function drawGraphLine(){if(allDataPoints.length<2)return;const cw=graphCanvas.clientWidth;const ch=parseFloat(getComputedStyle(graphCanvas).height)||graphCanvas.clientHeight;const{yMin,yMax}=computeYBounds(currentMaxDistance);let yRange=yMax-yMin;if(yRange<=0)yRange=1;ctx.beginPath();ctx.strokeStyle='#e74c3c';ctx.lineWidth=2.5;ctx.setLineDash([]);allDataPoints.forEach((pt,i)=>{const x=padding+(pt.time/Math.max(1e-9,currentMaxTime))*(cw-2*padding);const y=ch-padding-((pt.distance-yMin)/yRange)*(ch-2*padding);if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y)});ctx.stroke()}
function drawTimeCursor(){if(!isFinite(currentMaxTime)||currentMaxTime<=0)return;const cw=graphCanvas.clientWidth;const ch=parseFloat(getComputedStyle(graphCanvas).height)||graphCanvas.clientHeight;const clamped=Math.max(0,Math.min(currentMaxTime,timeCursor));const x=padding+(clamped/currentMaxTime)*(cw-2*padding);ctx.save();ctx.strokeStyle='rgba(0,120,255,0.9)';ctx.lineWidth=2;ctx.setLineDash([]);ctx.beginPath();ctx.moveTo(x,padding);ctx.lineTo(x,ch-padding);ctx.stroke();ctx.restore()}
function generateDataAndAnimate(){allDataPoints=[{time:0,distance:0}];let cumulativeTime=0;let cumulativeDistance=0;currentMaxTime=0;let minDist=0;let maxDist=0;segments.forEach(seg=>{currentMaxTime+=seg.duration;const step=0.1;for(let t=step;t<=seg.duration;t+=step){const interimTime=cumulativeTime+t;const interimDistance=cumulativeDistance+seg.velocity*t;allDataPoints.push({time:interimTime,distance:interimDistance})}cumulativeTime+=seg.duration;cumulativeDistance+=seg.velocity*seg.duration;allDataPoints.push({time:cumulativeTime,distance:cumulativeDistance});minDist=Math.min(minDist,cumulativeDistance);maxDist=Math.max(maxDist,cumulativeDistance)});allDataPoints=allDataPoints.filter((p,i,self)=>i===self.findIndex(q=>q.time===p.time)||i===self.length-1);currentMaxDistance=(minDist<0&&maxDist<=0)?Math.abs(minDist):(minDist<0&&maxDist>0)?Math.max(Math.abs(minDist),maxDist):maxDist;if(currentMaxTime===0)currentMaxTime=1;if(currentMaxDistance===0&&minDist===0)currentMaxDistance=1;drawAxes(currentMaxTime,currentMaxDistance);drawGraphLine();timeCursor=0;drawTimeCursor();sizeSimCanvas();drawSimNumberLine(minDist,maxDist,0);animateMovement()}
function animateMovement(){let segmentIndex=0;let totalTimeElapsed=0;let currentObjectDistance=0;let simStartTime=performance.now();const minS=allDataPoints.reduce((m,p)=>Math.min(m,p.distance),0);const maxS=allDataPoints.reduce((m,p)=>Math.max(m,p.distance),0);function step(ts){const elapsedMs=ts-simStartTime;totalTimeElapsed=elapsedMs/1000;if(segmentIndex>=segments.length||totalTimeElapsed>currentMaxTime){totalTimeElapsed=currentMaxTime;let finalDist=0;segments.forEach(s=>finalDist+=s.velocity*s.duration);currentObjectDistance=finalDist;timeDisplay.textContent=totalTimeElapsed.toFixed(1);distanceDisplay.textContent=currentObjectDistance.toFixed(1);drawSimNumberLine(minS,maxS,currentObjectDistance);timeCursor=totalTimeElapsed;drawAxes(currentMaxTime,currentMaxDistance);drawGraphLine();drawTimeCursor();return}let timePrev=0;for(let i=0;i<segmentIndex;i++)timePrev+=segments[i].duration;const seg=segments[segmentIndex];const timeWithin=totalTimeElapsed-timePrev;if(timeWithin>seg.duration){segmentIndex++;requestAnimationFrame(step);return}let distAtStart=0;for(let i=0;i<segmentIndex;i++)distAtStart+=segments[i].velocity*segments[i].duration;currentObjectDistance=distAtStart+seg.velocity*timeWithin;timeDisplay.textContent=totalTimeElapsed.toFixed(1);distanceDisplay.textContent=currentObjectDistance.toFixed(1);drawSimNumberLine(minS,maxS,currentObjectDistance);timeCursor=totalTimeElapsed;drawAxes(currentMaxTime,currentMaxDistance);drawGraphLine();drawTimeCursor();animationFrameId=requestAnimationFrame(step)}animationFrameId=requestAnimationFrame(step)}
const simPad=26;let lastSimState=null;
function drawSimNumberLine(minVal,maxVal,currentVal){if(minVal===maxVal){minVal-=1;maxVal+=1}lastSimState={min:minVal,max:maxVal,current:currentVal};snl.clearRect(0,0,simCanvas.width,simCanvas.height);const w=simCanvas.clientWidth;const h=simCanvas.clientHeight;const y=Math.round(h/2)+8;snl.strokeStyle='#333';snl.lineWidth=1.5;snl.setLineDash([]);snl.beginPath();snl.moveTo(simPad,y);snl.lineTo(w-simPad,y);snl.stroke();const range=maxVal-minVal;const targetTicks=6;const rawStep=range/targetTicks;const step=niceStep(rawStep);snl.font="12px 'Segoe UI', Arial";snl.fillStyle='#333';snl.textAlign='center';const firstTick=Math.ceil(minVal/step)*step;for(let v=firstTick;v<=maxVal+1e-9;v+=step){const x=simPad+((v-minVal)/range)*(w-2*simPad);snl.beginPath();snl.moveTo(x,y-8);snl.lineTo(x,y+8);snl.stroke();const lbl=(Math.abs(v)<1e-9)?'0':round(v).toString();snl.fillText(lbl,x,y+22)}if(minVal<0&&maxVal>0){const x0=simPad+((0-minVal)/range)*(w-2*simPad);snl.strokeStyle='#666';snl.beginPath();snl.moveTo(x0,y-12);snl.lineTo(x0,y+12);snl.stroke();snl.fillText('0',x0,y+22)}const mx=simPad+((currentVal-minVal)/range)*(w-2*simPad);snl.beginPath();snl.arc(mx,y,6,0,2*Math.PI);snl.fillStyle='#e74c3c';snl.fill();snl.strokeStyle='#fff';snl.lineWidth=1.5;snl.stroke()}
function niceStep(x){if(x<=0)return 1;const pow10=Math.pow(10,Math.floor(Math.log10(x)));const n=x/pow10;let m;if(n<1.5)m=1;else if(n<3.5)m=2;else if(n<7.5)m=5;else m=10;return m*pow10}
graphCanvas.addEventListener('mousemove',e=>{if(allDataPoints.length<2)return;const rect=graphCanvas.getBoundingClientRect();const mouseX=e.clientX-rect.left;const mouseY=e.clientY-rect.top;const cw=graphCanvas.clientWidth;const ch=parseFloat(getComputedStyle(graphCanvas).height)||graphCanvas.clientHeight;if(mouseX<padding||mouseX>cw-padding||mouseY<padding||mouseY>ch-padding){hoverInfo.style.display='none';drawAxes(currentMaxTime,currentMaxDistance);drawGraphLine();drawTimeCursor();return}const timeAtMouse=(mouseX-padding)/(cw-2*padding)*currentMaxTime;let distanceAtMouse=0;for(let i=0;i<allDataPoints.length-1;i++){const p1=allDataPoints[i],p2=allDataPoints[i+1];if(timeAtMouse>=p1.time&&timeAtMouse<=p2.time){const slope=(p2.distance-p1.distance)/(p2.time-p1.time||1e-9);distanceAtMouse=p1.distance+slope*(timeAtMouse-p1.time);break}}drawAxes(currentMaxTime,currentMaxDistance);drawGraphLine();drawTimeCursor();const{yMin,yMax}=computeYBounds(currentMaxDistance);let minY=yMin;let maxY=yMax;let yRange=maxY-minY;if(yRange<=0){yRange=1}const hoverX=padding+(timeAtMouse/currentMaxTime)*(cw-2*padding);const hoverY=ch-padding-((distanceAtMouse-minY)/yRange)*(ch-2*padding);ctx.beginPath();ctx.arc(hoverX,hoverY,5,0,2*Math.PI);ctx.fillStyle='rgba(0,100,255,.8)';ctx.fill();ctx.strokeStyle='#fff';ctx.lineWidth=1.5;ctx.stroke();hoverInfo.style.display='block';hoverInfo.style.left=`${e.clientX+15}px`;hoverInfo.style.top=`${e.clientY-15}px`;hoverInfo.innerHTML=`Time: ${timeAtMouse.toFixed(2)}s<br>Dist: ${distanceAtMouse.toFixed(2)}m`});
graphCanvas.addEventListener('mouseout',()=>{hoverInfo.style.display='none';if(allDataPoints.length){drawAxes(currentMaxTime,currentMaxDistance);drawGraphLine();drawTimeCursor()}});
explainBtn.addEventListener('click',()=>{if(!segments.length){helperOutput.value='Add at least one segment first.';return}const summary=buildExplanation(segments,allDataPoints);helperOutput.value=summary;helperOutput.scrollTop=0});
function buildExplanation(segs,points){let totalT=segs.reduce((s,v)=>s+v.duration,0);let totalD=segs.reduce((s,v)=>s+v.velocity*v.duration,0);let pathLen=segs.reduce((s,v)=>s+Math.abs(v.velocity*v.duration),0);let avgV=totalT>0?totalD/totalT:0;let maxSpeed=0,maxIdx=-1;segs.forEach((s,i)=>{if(Math.abs(s.velocity)>Math.abs(maxSpeed)){maxSpeed=s.velocity;maxIdx=i}});const dirChanges=segs.slice(1).filter((s,i)=>Math.sign(s.velocity)!==Math.sign(segs[i].velocity)&&s.velocity!==0).length;const rests=segs.filter(s=>s.velocity===0).length;const bullet=t=>`• ${t}`;let lines=[];lines.push('What this run shows:');lines.push(bullet(`Total time = ${round(totalT)} s`));lines.push(bullet(`Net distance (signed) = ${round(totalD)} m`));lines.push(bullet(`Path length (how far traveled in total) = ${round(pathLen)} m`));lines.push(bullet(`Average velocity = ${round(avgV)} m/s`));if(maxIdx>=0)lines.push(bullet(`Top speed at Segment ${maxIdx+1} = ${round(maxSpeed)} m/s (${speedWord(maxSpeed)})`));if(rests>0)lines.push(bullet(`${rests} at-rest segment${rests>1?'s':''} (flat parts on the graph)`));if(dirChanges>0)lines.push(bullet(`${dirChanges} direction change${dirChanges>1?'s':''} (slope sign flips)`));lines.push('\nSegment-by-segment:');segs.forEach((s,i)=>{const kind=s.velocity===0?'rest':`constant velocity (${speedWord(s.velocity)})`;const delta=s.velocity*s.duration;const sign=delta===0?'':delta>0?'away from start':'toward start';lines.push(bullet(`S${i+1}: ${kind} for ${round(s.duration)} s → Δd = ${round(delta)} m ${sign}`))});const oneLiner=graphOneLiner(segs);if(oneLiner){lines.push('\nGraph in words:');lines.push(bullet(oneLiner))}lines.push('\nQuick checks:');lines.push(bullet('Flat parts = rest (slope 0).'));lines.push(bullet('Steeper line = faster speed (|slope|).'));lines.push(bullet('Negative slope = moving toward the origin.'));return lines.join('\n')}
function graphOneLiner(segs){if(!segs.length)return'';const phrases=[];segs.forEach(s=>{if(s.velocity===0)phrases.push('flat');else if(s.velocity>0)phrases.push('rising straight');else phrases.push('falling straight')});return phrases.join(' → ')+' line segments (no curves because velocity is constant in each segment).'}
function round(x){return Math.round(x*100)/100}
function speedWord(v){return v>0?'away (+)':v<0?'toward (−)':'rest'}
clearGraph();drawSimNumberLine(0,10,0);
(function selfTests(){console.assert(typeof drawAxes==='function','drawAxes exists');console.assert(typeof drawGraphLine==='function','drawGraphLine exists');console.assert(typeof drawTimeCursor==='function','drawTimeCursor exists');const ptsExample=[{velocity:2,duration:5},{velocity:-10,duration:5}];let pts=[{time:0,distance:0}],t=0,d=0;ptsExample.forEach(seg=>{const step=0.5;for(let k=step;k<=seg.duration;k+=step){pts.push({time:t+k,distance:d+seg.velocity*k})}t+=seg.duration;d+=seg.velocity*seg.duration;pts.push({time:t,distance:d})});let mn=pts[0].distance,mx=pts[0].distance;pts.forEach(p=>{mn=Math.min(mn,p.distance);mx=Math.max(mx,p.distance)});console.assert(Math.abs(mn+40)<0.6&&Math.abs(mx-10)<0.6,'axis bounds');// addSegmentBtn.click(); // removed to prevent preloading a segment
console.assert(document.querySelectorAll('#segmentsList li').length>=1,'segment add')})();
</script>
</body>
</html>
